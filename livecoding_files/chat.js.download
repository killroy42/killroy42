"use strict";

var CandyShop = (function(self) { return self; }(CandyShop || {}));

window.Chat = (function (self, $, Candy, CandyShop, Raven) {
    var sessionRetryDelay = 500,
        sessionRetryPending = false,
        wasKickedOut = null,
        sessionUrl = null,
        hasWebsockets = "WebSocket" in window && window.WebSocket.CLOSING === 2,
        useWebsockets = false,
        pingIntervalId = null,
        pingIntervalMS = 30000,
        initRoomJid = null;

    var makeWebsocketUrl = function (path, hostnameOverride) {
            // Given a path, contruct an absolute Websocket URL, based on current host (including port and schema)
            var l = window.location;
            var hostname = hostnameOverride;
            if (!hostnameOverride) {
                hostname = l.hostname;
                if (hostname == "www.livecoding.tv") {
                    hostname = "ws.www.livecoding.tv";
                } else if (hostname == "staging.livecoding.tv") {
                    hostname = "ws.staging.livecoding.tv";
                } else if (hostname == "dev.livecoding.tv") {
                    hostname = "ws.dev.livecoding.tv";
                }
            }
            return ((l.protocol === "https:") ? "wss://" : "ws://") + hostname
                   + ((l.port && (   (l.protocol === "http:" && l.port != 80)
                                  || (l.protocol === "https:" && l.port != 443))) ? ":" + l.port : "")
                   + path;
        },
        websocketUrl = function (urlOrPath) {
            // Does the same as function above, but only if the string is not absolute URL (does not contain "://")
            if (urlOrPath.indexOf("://") >= 0) {
                return urlOrPath;
            } else {
                return makeWebsocketUrl(urlOrPath);
            }
        };

    self.init = function(settings) {
        var $container = $('.jwplayer-livestream-main-container'),
            ratio = 16/9,
            chatUrl = settings.chatUrlBosh;

        $container.add('.candy_container').css('height', $container.width()/ratio + 'px');
        sessionUrl = settings.sessionSetupUrl;

        if (settings.useWebsockets && hasWebsockets) {
            chatUrl = websocketUrl(settings.chatUrlWs);
            useWebsockets = true;
        }
        if (settings.pingInterval !== null) {
            pingIntervalMS = settings.pingInterval;
        }

        initRoomJid = settings.roomJid;
        Candy.init(chatUrl, {
            core: {
                debug: settings.debug,
                disableWindowUnload: settings.disableWindowUnload,
                autojoin: [settings.roomJid],
                resource: settings.resource
            },
            view: {
                assets: settings.assets,
                enableXHTML: true
            }
        });

        // Plugins
        if (CandyShop.NameComplete) {
            CandyShop.NameComplete.init({
                nameIdentifier: '@',
                completeKeyCode: 9 /* tab */
            });
        }
        if (CandyShop.ModifyRole) {
          CandyShop.ModifyRole.init();
        }
        if (CandyShop.LivecodingExtras) {
            CandyShop.LivecodingExtras.init(settings.premium, settings.nickColor,
                                            settings.prohibitedColors, settings.deltaEThreshold);
        } else if (Raven) {
            Raven.captureMessage(
                "Candy-Chat.js: Livecoding.tv extras are not loaded!",
                {extra: { "roomJid": settings.roomJid }}
            );
        }

        // Disable private channels
        Candy.View.Pane.Roster.userClick = function() {};

        var scrollPaneAPI = null,
            paneShowTime = null;
        $(Candy).on('candy:view.room.after-show', function(evt, args) {
            var pane = $('.message-pane-wrapper').jScrollPane({
                autoReinitialise: true,
                stickToBottom: true,
                forcePaneWidth: '100%'
            });
            scrollPaneAPI = pane.data("jsp");
            scrollPaneAPI.scrollToBottom();
            paneShowTime = +new Date();
        });
        $(window).resize(function () {
            if (scrollPaneAPI) {
                scrollPaneAPI.reinitialise();
                scrollPaneAPI.scrollToBottom();
            }
        });
        $(Candy).on('candy:view.message.after-show', function(evt, args) {
            if (scrollPaneAPI) {
                scrollPaneAPI.reinitialise();
                scrollPaneAPI.scrollToBottom();
            }
            var now = +new Date();
            // Don't play sounds for first 3 seconds after joining the room (showing the chat pane)
            if (paneShowTime <= now - 3000) {
                Candy.View.Pane.Chat.Toolbar.playSound();
            }
            // Activate highlight js
            $('pre code').each(function(i, block) {
                if (!($(this).hasClass('hljs'))) {
                    hljs.highlightBlock(block);
                }
            });
        });

        $(Candy).on("candy:lctv.color-change", function(evt, args) {
            var color = args.color;
            // Eventually, this $.post won't be required and color could be fully persisted with presence stanza.
            $.post(settings.colorChangeUrl, {color: color}, function (data) {
                Candy.Core.log("Color update: " + JSON.stringify(data));
                if (data.changed) {
                    var extra = $build("x", {xmlns: "https://www.livecoding.tv/xmpp/muc#user"})
                        .c("item", {color: color}).up();
                    Candy.Core.Action.Jabber.Presence({to: settings.roomJid}, extra);
                    CandyShop.LivecodingExtras.updateColor(data.color);
                }
            });
        });

        var _nicks = [];
        var populateNicks = function() {
		    _nicks = [];
    		var room = Candy.Core.getRoom(Candy.View.getCurrent().roomJid);
    		if (room !== null) {
    			var roster = room.getRoster().getAll();
			    $.each(roster, function(index, item) {
    				_nicks.push(_options.nameIdentifier + item.getNick());
    			});
	    	}
	    };

        window.hideChatActions = ["leave"]; // This is global so it can be manipulated
        $(Candy).on('candy:view.roster.message-update', function (evt, args) {
            // console.log(args.action + " : " + args.user.getJid());
            if ($.inArray(args.action, window.hideChatActions) >= 0) {
                return false;
            }
        });

        var slugify = function (nickname) {
            return nickname.toLowerCase().replace(/[^\w\s-]/, "").replace(/[-\s]+/, "-");
        };

        var findByNickname = function (roomJid, name) {
            var room = Candy.Core.getRoom(roomJid);
            if (room != null) {
                var roster = room.getRoster().getAll();
                var found = null;
                $.each(roster, function (index, item) {
                    if (item.getNick() === name) {
                        found = item;
                        return false;
                    } else {
                        return true;
                    }
                });
                return found;
            }
            return null;
        };

        /* This is ugly, but all I have here is nickname, not JID. So, please, don't hate me. */
        $(Candy).on('candy:view.message.before-render', function(evt, args) {
            try {
                if (args.templateData && args.templateData.name) {
                    args.templateData.displayNameSlug = slugify(args.templateData.name);
                    args.templateData.userLink = "/" + args.templateData.displayNameSlug + "/";

                    var extraClasses = [];
                    if (args.isDelayed) {
                        extraClasses.push("delayed");
                    }

                    var found = findByNickname(args.templateData.roomJid, args.templateData.name);
                    if (found) {
                        args.templateData.role = found.getRole();
                        args.templateData.affiliation = found.getAffiliation();
                        var data = found.getCustomData();
                        if (data.premium === "true") {
                            extraClasses.push("lctv-premium");
                        }
                        if (data.staff === "true") {
                            extraClasses.push("lctv-staff");
                        }
                        if (typeof data.color !== "undefined" && data.color !== null && data.color !== "") {
                            args.templateData.userColor = data.color;
                        }
                    }
                    if (extraClasses.length > 0) {
                        args.templateData.extraMsgClasses = extraClasses.join(" ");
                    }
                }
            } catch(err) {
                if (console && console.log) { console.log("Exception in message.before-render", err); }
                if (Raven) { Raven.captureException(err); }
            }
        });

        // Same story as with "before-render" event above. No JID, only name.
        // We've hacked Candy.Util.Parser.all to NOT emotify anything. We do it here, where we know the sender.
        $(Candy).on('candy:view.message.before-show', function(evt, args) {
            try {
                var found = findByNickname(args.roomJid, args.name);
                var isPro = false;
                if (found) {
                    var premiumState = found.getCustomData().premium;
                    isPro = premiumState === "true" || premiumState === true;
                }
                args.message = Candy.Util.Parser.emotify(args.message, isPro);
            } catch (err) {
                if (console && console.log) { console.log("Exception in message.before-show", err); }
                if (Raven) { Raven.captureException(err); }
            }
            return true;
        });

        var retryCount = 0;
        Candy.View.Pane.Chat.allTabsClosed = function () {
            if (!wasKickedOut) {
                retryCount += 1;
                if (retryCount < 4) {
                    Candy.Core.Action.Jabber.Room.Join(settings.roomJid);
                } else {
                    Candy.Core.disconnect();
                    self.Chat.Toolbar.hide();
                }
            } else {
                Candy.View.Pane.Chat.Modal.show(
                    wasKickedOut === "kick"
                        ? "You have been kicked out of the chatroom."
                        : "You have been banned from this chatroom.",
                    false, false
                );
            }
        };
        Candy.View.Pane.Chat.Modal.showLoginForm = function (message, presetJid) {
            Candy.View.Pane.Chat.Modal.show(message ? message : "(disconnected)");
            self.stopPings();
            if (!wasKickedOut) { self.retryConnect(null); }
            else if (wasKickedOut === "conflict") {
                Candy.View.Pane.Chat.Modal.show("You have opened this chatroom in another window or tab.", false, false);
            }
        };

        $(Candy).on("candy:core.presence.leave", function (event, data) {
            if (data.type === "kick" || data.type === "ban") {
                wasKickedOut = data.type;
            }
        });

        $(Candy).on("candy:core.presence.error", function (event, data) {
            if (data.type === "forbidden") {
                wasKickedOut = true;
                var text = data.msg.find("> error > text").text();
                Candy.View.Pane.Chat.Modal.show(text || "You have been banned from this chatroom.", false, false);
                self.stopPings();
            }
        });

        $(Candy).on("candy:core.error-conflict", function (event, data) {
            wasKickedOut = "conflict"; // We weren't really kicked out, but use the same mechanism to prevent reconnection
            //Candy.Core.disconnect(); // Because Candy/Strophe would otherwise try to reconnect in such case
            try {
                var text = data.stanza ? $("stream\\\:error > text[xmlns='urn:ietf:params:xml:ns:xmpp-streams']", data.stanza).text() : null;
                Candy.Core.log("[Connection] Conflict" + (text ? ": " + text : ""));
            } catch(err) {
                if (Raven) { Raven.captureException(err); }
            }
        });
        $(Candy).on("candy:core.chat.connection", function (event, data) {
            console.log("candy:core.chat.connection", data);
            try {
                var status = data.status;
                if (status == Strophe.Status.CONNECTED) {
                    // Reset the delay on successful connection.
                    sessionRetryDelay = Math.min(sessionRetryDelay, 1000);
                    retryCount = 0;
                    if (useWebsockets) {
                        // Only send pings with Websocket-based connections,
                        // with BOSH they'll be more of a problem than help.
                        self.startPings();
                    }
                }
                if (status == Strophe.Status.AUTHFAIL || status == Strophe.Status.DISCONNECTED || status == Strophe.Status.CONNFAIL) {
                    // Disconnected. Fetch a new credentials (password or pre-binding IDs) and retry.
                    self.stopPings();
                    if (!wasKickedOut) {
                        self.retryConnect(null);
                    }
                }
            } catch(err) {
                if (console && console.log) { console.log("Exception in core.chat.connection", err); }
                if (Raven) { Raven.captureException(err); }
            }
        });

        $(document).on("keydown", "#message-textarea", function(e) {
            var key = e.keyCode ? e.keyCode : e.charCode ? e.charCode : false;
			if (key === 13 && (e.ctrlKey || $('#sendonenter').is(':checked'))) {
                $("form.message-form").submit();
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                }
				return false;
			}
		});
    };

    self.startPings = function () {
        self.stopPings();
        if (pingIntervalMS === null || pingIntervalMS < 1000) {
            // Don't do anything, consider pings disabled.
            return;
        }
        Candy.Core.log("[Ping] Will send XMPP pings every " + pingIntervalMS + " ms");
        pingIntervalId = window.setInterval(function () {
            try {
                var conn = Candy.Core.getConnection();
                if (conn && conn.connected && conn.authenticated) {
                    conn.sendIQ(
                        $iq({
                            type: "get",
                            to: "livecoding.tv"
                        }).c("ping", {xmlns: "urn:xmpp:ping"}),
                        function (stanza) {
                            var rType = stanza.getAttribute("type");
                            if (rType !== "result") {
                                self.stopPings();
                                if (Raven) { Raven.captureMessage("Got invalid IQ response " + rType + " for XMPP ping: " + stanza); }
                                Candy.Core.log("Ping error: " + stanza);
                            }
                        }
                    );
                }
            } catch(_e) { /* Do nothing */ }
        }, pingIntervalMS);
    };

    self.stopPings = function () {
        if (pingIntervalId !== null) {
            window.clearInterval(pingIntervalId);
            pingIntervalId = null;
            Candy.Core.log("[Ping] XMPP ping sending interval cleared");
        }
    };

    self.retryConnect = function (promiseId) {
        Candy.Core.log("[Debug] Will retry connection (promiseId: " + promiseId + "; wasKickedOut: " + wasKickedOut + ")");

        var delay = sessionRetryDelay;
        sessionRetryDelay = sessionRetryDelay * 2;
        if (sessionRetryDelay > 10000) { sessionRetryDelay = 10000; }
        if (sessionRetryPending) { return false; }

        wasKickedOut = false;
        sessionRetryPending = true;
        setTimeout(function () {
            sessionRetryPending = false;
            self.startSession(promiseId);
        }, delay);
    };

    self.startSession = function (promiseId) {
        if (typeof promiseId === "undefined" || promiseId === null || promiseId === "None") { promiseId = ""; }
        $.post(
            sessionUrl,
            {"promise_id": promiseId, "websockets": useWebsockets ? "true" : "false"}
        ).success(self.connect).error(function () {
            Candy.View.Pane.Chat.Modal.showError("My dear, your chat is loading");
            if (Raven) {
                Raven.captureMessage(
                    "Failed to connect to chat service",
                    {extra: { "roomJid": initRoomJid }}
                );
            }
        });
    };

    self.connect = function (binding, promiseId) {
        promiseId = promiseId || binding ? binding.promise_id : "";

        if (binding === null || binding.delayed || binding.error) {
            if (binding !== null && binding.error) {
                // Task had failed, forget the ID and retry.
                promiseId = "";
            }
            self.retryConnect(promiseId);
        } else if (binding.anonymous) {
            Candy.Core.connect(binding.anonymous, null, "guest__" + Math.random().toString(36).slice(2));
        } else if (binding.jid && binding.password) {
            Candy.Core.connect(binding.jid, binding.password);
        } else if (binding.jid && binding.sid && binding.rid) {
            Candy.Core.attach(binding.jid, binding.sid, binding.rid);
        } else {
            // Should never happen. Means we have a problem at backend.
            if (Raven) {
                Raven.captureMessage("chat/connect received invalid binding data: " + JSON.stringify(binding),
                                     {extra: { "roomJid": initRoomJid }});
            }
            Candy.View.Pane.Chat.Modal.showError("My dear, your chat is loading");
            self.retryConnect(null);
        }
    };

    return self;
})(window.Chat || {}, jQuery, Candy, CandyShop, typeof window.Raven !== "undefined" ? window.Raven : null);
