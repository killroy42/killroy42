"use strict";

/**
 * Wrapped for in-browser use and few extra functions by Aleksey Zhukov, 2015.
 *
 * @author Markus Ekholm
 * @copyright 2012-2015 (c) Markus Ekholm <markus at botten dot org >
 * @license Copyright (c) 2012-2015, Markus Ekholm
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *    * Redistributions of source code must retain the above copyright
 *      notice, this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of the <organization> nor the
 *      names of its contributors may be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL MARKUS EKHOLM BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

window.ColorUtils = (function (self) {
    /**
     * JSDoc type definitions
     *
     * @typedef {Object} rgbcolor
     * @property {number} R - red component, between 0 and 255
     * @property {number} G - green component, between 0 and 255
     * @property {number} B - blue component, between 0 and 255
     *
     * @typedef {Object} rgbacolor
     * @property {number} R - red component, between 0 and 255
     * @property {number} G - green component, between 0 and 255
     * @property {number} B - blue component, between 0 and 255
     * @property {number} A - alpha component, between 0 and 255
     *
     * @typedef {Object} hslcolor
     * @property {number} H - hue component, between 0 and 1
     * @property {number} S - saturation component, between 0 and 1
     * @property {number} L - lightness component, between 0 and 1
     *
     * @typedef {Object} xyzcolor
     * @property {number} X
     * @property {number} Y
     * @property {number} Z
     *
     * @typedef {Object} labcolor
     * @property {number} L
     * @property {number} a
     * @property {number} b
     */

    /**
     * IMPORTS
     */
    var pow = Math.pow;
    var sqrt = Math.sqrt;
    var cos = Math.cos;
    var atan2 = Math.atan2;
    var sin = Math.sin;
    var abs = Math.abs;
    var exp = Math.exp;
    var PI = Math.PI;
    var min = Math.min;
    var max = Math.max;

    /**
     * INTERNAL FUNCTIONS
     */
    var degrees = function (n) { return n * (180 / PI); },
        radians = function (n) { return n * (PI / 180); };

    /**
     * API FUNCTIONS
     */

    /*
     * Returns RGB hex-encoded string with optional "#" prefix decoded to RGB object.
     * @param {string} s hex-encoded 32-bit RGB color, two digits per channel, like "#aabbcc"
     * @param {boolean} dontThrow if true, return null instead of throwing exception
     * @return {rgbcolor|null} s converted to rgbcolor
     */
    self.parse_rgb = function (s, dontThrow) {
        var m = /^#?([0-9A-Fa-f]{6})$/.exec(s);
        if (m !== null) {
            m = m[1];
            return {
                'R': parseInt(m.substr(0, 2), 16),
                'G': parseInt(m.substr(2, 2), 16),
                'B': parseInt(m.substr(4, 2), 16)
            };
        } else {
            if (dontThrow) { return null; }
            else           { throw new Error("Invalid RGB color string: " + s); }
        }
    };

    /*
     * Given an RGB color, returns an RGB hex-encoded string
     * @param {rgbcolor} c color to stringify
     * @param {boolean} noHash if true, don't include "#" prefix
     * @return {string} c converted to string
     */
    self.stringify_rgb = function (c, noHash) {
        return (noHash ? "" : "#") + ((1 << 24) + (c.R << 16) + (c.G << 8) + c.B).toString(16).slice(1,7);
    };

    /**
     * Returns c converted to labcolor. Uses bc as background color,
     * deaults to using white as background color.
     * @param {rgbacolor} c RGBA color, should have fields R,G,B,A
     * @param {rgbcolor} b background color, should have fields R,G,B
     * @return {labcolor} c converted to labcolor
     */
    self.rgba_to_lab = function (c, b) {
        var bc = typeof b !== 'undefined' ? b : {R: 255, G: 255, B: 255};
        var new_c = {
            R: bc.R + (c.R - bc.R) * c.A,
            G: bc.G + (c.G - bc.G) * c.A,
            B: bc.B + (c.B - bc.B) * c.A
        };
        return self.rgb_to_lab(new_c)
    };

    /**
     * Returns c converted to hslcolor.
     * @param {rgbcolor} c should have fields R,G,B
     * @return {hslcolor} c converted to hslcolor
     */
    self.rgb_to_hsl = function (c) {
        // Based on http://www.easyrgb.com/index.php?X=MATH&H=18#text18
        var var_R = c.R / 255,                      // RGB from 0 to 255
            var_G = c.G / 255,
            var_B = c.B / 255,
            var_Min = min(var_R, var_G, var_B),     // Min. value of RGB
            var_Max = max(var_R, var_G, var_B),     // Max. value of RGB
            del_Max = var_Max - var_Min,            // Delta RGB value
            L = (var_Max + var_Min) / 2,
            H, S;

        if (del_Max == 0) {                         // This is a gray, no chroma...
            H = 0;                                  // HSL results from 0 to 1
            S = 0;
        } else {                                    // Chromatic data...
            if (L < 0.5) { S = del_Max / (var_Max + var_Min); }
            else         { S = del_Max / (2 - var_Max - var_Min); }

            var del_R = (((var_Max - var_R ) / 6) + (del_Max / 2)) / del_Max,
                del_G = (((var_Max - var_G ) / 6) + (del_Max / 2)) / del_Max,
                del_B = (((var_Max - var_B ) / 6) + (del_Max / 2)) / del_Max;

            if      ( var_R == var_Max ) { H = del_B - del_G; }
            else if ( var_G == var_Max ) { H = ( 1 / 3 ) + del_R - del_B; }
            else if ( var_B == var_Max ) { H = ( 2 / 3 ) + del_G - del_R; }

            if ( H < 0 ) { H += 1 }
            if ( H > 1 ) { H -= 1 }
        }
        return {'H': H, 'S': S, 'L': L};
    };

    var hue_to_rgb = function(v1, v2, vH) {
        // Helper function for hsl_to_rgb
        if (vH < 0) { vH += 1; }
        if (vH > 1) { vH -= 1; }

        if ((6 * vH) < 1) { return (v1 + ( v2 - v1 ) * 6 * vH); }
        else if ((2 * vH) < 1) { return v2; }
        else if ((3 * vH) < 2) { return (v1 + (v2 - v1) * ((2 / 3) - vH) * 6); }
        else { return v1; }
    };

    /**
     * Returns c converted to rgbcolor.
     * @param {hslcolor} c should have fields H,S,L
     * @return {rgbcolor} c converted to rgbcolor
     */
    self.hsl_to_rgb = function (c) {
        // Based on http://www.easyrgb.com/index.php?X=MATH&H=19#text19
        if (c.S == 0) {                      // HSL from 0 to 1
            return {'R': c.L * 255, 'G': c.L * 255, 'B': c.L * 255};
        } else {
            var var_2 = (c.L < 0.5) ? c.L * (1 + c.S) : (c.L + c.S) - (c.S * c.L),
                var_1 = 2 * c.L - var_2;
            return {
                'R': 255 * hue_to_rgb(var_1, var_2, c.H + (1 / 3)),
                'G': 255 * hue_to_rgb(var_1, var_2, c.H),
                'B': 255 * hue_to_rgb(var_1, var_2, c.H - (1 / 3))
            };
        }
    };

    /**
     * Returns c converted to labcolor.
     * @param {rgbcolor} c should have fields R,G,B
     * @return {labcolor} c converted to labcolor
     */
    self.rgb_to_lab = function (c) {
        return self.xyz_to_lab(self.rgb_to_xyz(c))
    };

    /**
     * Returns c converted to xyzcolor.
     * @param {rgbcolor} c should have fields R,G,B
     * @return {xyzcolor} c converted to xyzcolor
     */
    self.rgb_to_xyz = function (c) {
        // Based on http://www.easyrgb.com/index.php?X=MATH&H=02
        var R = ( c.R / 255 );
        var G = ( c.G / 255 );
        var B = ( c.B / 255 );

        if (R > 0.04045) R = pow(( ( R + 0.055 ) / 1.055 ), 2.4);
        else               R = R / 12.92;
        if (G > 0.04045) G = pow(( ( G + 0.055 ) / 1.055 ), 2.4);
        else               G = G / 12.92;
        if (B > 0.04045) B = pow(( ( B + 0.055 ) / 1.055 ), 2.4);
        else               B = B / 12.92;

        R *= 100;
        G *= 100;
        B *= 100;

        // Observer. = 2°, Illuminant = D65
        var X = R * 0.4124 + G * 0.3576 + B * 0.1805;
        var Y = R * 0.2126 + G * 0.7152 + B * 0.0722;
        var Z = R * 0.0193 + G * 0.1192 + B * 0.9505;
        return {'X': X, 'Y': Y, 'Z': Z};
    };

    /**
     * Returns c converted to labcolor.
     * @param {xyzcolor} c should have fields X,Y,Z
     * @return {labcolor} c converted to labcolor
     */
    self.xyz_to_lab = function (c) {
        // Based on http://www.easyrgb.com/index.php?X=MATH&H=07
        var ref_Y = 100.000;
        var ref_Z = 108.883;
        var ref_X = 95.047; // Observer= 2°, Illuminant= D65
        var Y = c.Y / ref_Y;
        var Z = c.Z / ref_Z;
        var X = c.X / ref_X;
        if (X > 0.008856) X = pow(X, 1 / 3);
        else                X = ( 7.787 * X ) + ( 16 / 116 );
        if (Y > 0.008856) Y = pow(Y, 1 / 3);
        else                Y = ( 7.787 * Y ) + ( 16 / 116 );
        if (Z > 0.008856) Z = pow(Z, 1 / 3);
        else                Z = ( 7.787 * Z ) + ( 16 / 116 );
        var L = ( 116 * Y ) - 16;
        var a = 500 * ( X - Y );
        var b = 200 * ( Y - Z );
        return {'L': L, 'a': a, 'b': b};
    };

    /**
     * Returns diff between c1 and c2 using the CIEDE2000 algorithm
     * @param {labcolor} c1    Should have fields L,a,b
     * @param {labcolor} c2    Should have fields L,a,b
     * @return {float}   Difference between c1 and c2
     */
    self.ciede2000 = function (c1, c2) {
        /**
         * Implemented as in "The CIEDE2000 Color-Difference Formula:
         * Implementation Notes, Supplementary Test Data, and Mathematical Observations"
         * by Gaurav Sharma, Wencheng Wu and Edul N. Dalal.
         */

        // Get L,a,b values for color 1
        var L1 = c1.L;
        var a1 = c1.a;
        var b1 = c1.b;

        // Get L,a,b values for color 2
        var L2 = c2.L;
        var a2 = c2.a;
        var b2 = c2.b;

        // Weight factors
        var kL = 1;
        var kC = 1;
        var kH = 1;

        /**
         * Step 1: Calculate C1p, C2p, h1p, h2p
         */
        var C1 = sqrt(pow(a1, 2) + pow(b1, 2)); //(2)
        var C2 = sqrt(pow(a2, 2) + pow(b2, 2)); //(2)

        var a_C1_C2 = (C1 + C2) / 2.0;          //(3)

        var G = 0.5 * (1 - sqrt(pow(a_C1_C2, 7.0) /
                (pow(a_C1_C2, 7.0) + pow(25.0, 7.0)))); //(4)

        var a1p = (1.0 + G) * a1; //(5)
        var a2p = (1.0 + G) * a2; //(5)

        var C1p = sqrt(pow(a1p, 2) + pow(b1, 2)); //(6)
        var C2p = sqrt(pow(a2p, 2) + pow(b2, 2)); //(6)

        var hp_f = function (x, y) //(7)
        {
            if (x == 0 && y == 0) return 0;
            else {
                var tmphp = degrees(atan2(x, y));
                if (tmphp >= 0) { return tmphp; }
                else            { return tmphp + 360; }
            }
        };

        var h1p = hp_f(b1, a1p); //(7)
        var h2p = hp_f(b2, a2p); //(7)

        /**
         * Step 2: Calculate dLp, dCp, dHp
         */
        var dLp = L2 - L1; //(8)
        var dCp = C2p - C1p; //(9)

        var dhp_f = function (C1, C2, h1p, h2p) //(10)
        {
            if (C1 * C2 == 0)               return 0;
            else if (abs(h2p - h1p) <= 180) return h2p - h1p;
            else if ((h2p - h1p) > 180)     return (h2p - h1p) - 360;
            else if ((h2p - h1p) < -180)    return (h2p - h1p) + 360;
            else                         throw(new Error());
        };
        var dhp = dhp_f(C1, C2, h1p, h2p); //(10)
        var dHp = 2 * sqrt(C1p * C2p) * sin(radians(dhp) / 2.0); //(11)

        /**
         * Step 3: Calculate CIEDE2000 Color-Difference
         */
        var a_L = (L1 + L2) / 2.0; //(12)
        var a_Cp = (C1p + C2p) / 2.0; //(13)

        var a_hp_f = function (C1, C2, h1p, h2p) { //(14)
            if (C1 * C2 == 0)                                        { return h1p + h2p; }
            else if (abs(h1p - h2p) <= 180)                          { return (h1p + h2p) / 2.0; }
            else if ((abs(h1p - h2p) > 180) && ((h1p + h2p) < 360))  { return (h1p + h2p + 360) / 2.0; }
            else if ((abs(h1p - h2p) > 180) && ((h1p + h2p) >= 360)) { return (h1p + h2p - 360) / 2.0; }
            else                                                     { throw(new Error("Error in CIEDE2000.a_hp_f")); }
        };
        var a_hp = a_hp_f(C1, C2, h1p, h2p); //(14)
        var T = 1 - 0.17 * cos(radians(a_hp - 30)) + 0.24 * cos(radians(2 * a_hp)) +
            0.32 * cos(radians(3 * a_hp + 6)) - 0.20 * cos(radians(4 * a_hp - 63)); //(15)
        var d_ro = 30 * exp(-(pow((a_hp - 275) / 25, 2))); //(16)
        var RC = sqrt((pow(a_Cp, 7.0)) / (pow(a_Cp, 7.0) + pow(25.0, 7.0)));//(17)
        var SL = 1 + ((0.015 * pow(a_L - 50, 2)) /
            sqrt(20 + pow(a_L - 50, 2.0)));//(18)
        var SC = 1 + 0.045 * a_Cp;//(19)
        var SH = 1 + 0.015 * a_Cp * T;//(20)
        var RT = -2 * RC * sin(radians(2 * d_ro));//(21)
        var dE = sqrt(pow(dLp / (SL * kL), 2) + pow(dCp / (SC * kC), 2) +
            pow(dHp / (SH * kH), 2) + RT * (dCp / (SC * kC)) *
            (dHp / (SH * kH))); //(22)
        return dE;
    };

    return self;
})(window.ColorUtils || {});
